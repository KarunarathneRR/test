/* ISC (c) 2018+ Jackens * https://github.com/jackens/sanitize-xml */

(function (E, W) {
  var SPLIT_COMMENT = /(<!--(?:.|\r|\n)*?-->)/
  var SPLIT_XML = /(<[^<]*)/
  var PROLOG = /^<\?xml\s*((?:.|\r|\n)*?)\s*\?>((?:.|\r|\n)*)$/
  var SELF_CLOSING = /^<(\w(?::|-|\w)*)\s*((?:.|\r|\n)*)\s*\/>((?:.|\r|\n)*)$/
  var OPENING = /^<(\w(?::|-|\w)*)\s*((?:.|\r|\n)*)\s*>((?:.|\r|\n)*)$/
  var CLOSING = /^<\/(\w(?::|-|\w)*)\s*>((?:.|\r|\n)*)$/
  var ATTRIBUTES = /(\w(?::|-|\w)*)(?:\s*=\s*('.*?'|".*?"))?/g

  var defaultOptions = {
    allowedTags: { a: { href: true }, b: {}, blockquote: {}, br: {}, del: {}, div: {}, em: {}, figcaption: {}, figure: {}, font: {}, h1: {}, h2: {}, h3: {}, h4: {}, h5: {}, h6: {}, hr: {}, i: {}, img: { src: true, alt: true }, li: {}, ol: {}, p: {}, s: {}, span: {}, strong: {}, sub: {}, sup: {}, table: {}, tbody: {}, td: {}, tfoot: {}, th: {}, thead: {}, tr: {}, u: {}, ul: {} },
    caseInsensitiveTags: true,
    caseInsensitiveAttributes: true,
    removeComments: true,
    disableProlog: true
  }
  var prologOptions = {
    allowedTags: {
      '?xml': { version: true, encoding: true, standalone: true }
    },
    caseInsensitiveTags: false
  }

  function sanitizeAttributes (tag, attributes, options) {
    var result = []
    do {
      var s = ATTRIBUTES.exec(attributes)
      if (s) {
        var name = options.caseInsensitiveAttributes ? s[1].toLowerCase() : s[1]
        var value = s[2]
        if (options.allowedTags[tag][name]) {
          result.push([name, value ? '=' : '', value].join(''))
        }
      }
    } while (s)
    return result.join(' ')
  }

  function format (chunks) {
    chunks[chunks.length - 1] = chunks[chunks.length - 1].replace(/>/g, '&gt;')
    return chunks.join('')
  }

  function $ (xml, customOptions) {
    var options = {}
    Object.keys(defaultOptions).forEach(function (key) {
      options[key] = customOptions !== undefined && customOptions !== null &&
        ({}).toString.call(customOptions[key]) === ({}).toString.call(defaultOptions[key])
        ? customOptions[key] : defaultOptions[key]
    })
    var openedTags = []

    function getClosingTag (tag) {
      return tag.allowed ? ['</', tag.name, '>'].join('') : ''
    }

    function atAllowedPath () {
      return !openedTags.length || openedTags[openedTags.length - 1].allowed
    }

    return (xml || '').split(SPLIT_COMMENT).map(function (block, blockIndex) {
      if (blockIndex % 2) {
        return options.removeComments ? '' : block
      } else {
        return block.split(SPLIT_XML).map(function (chunk, chunkIndex) {
          var s, tag, attributes

          if (!options.disableProlog && blockIndex === 0 && chunkIndex === 1) {
            s = chunk.match(PROLOG)
            if (s) {
              attributes = sanitizeAttributes('?xml', s[1], prologOptions)
              return format(['<?xml', attributes ? ' ' : '', attributes, ' ?>', s[2]])
            }
          }

          s = chunk.match(CLOSING)
          if (s) {
            tag = options.caseInsensitiveTags ? s[1].toLowerCase() : s[1]
            for (var index = openedTags.length - 1; index >= 0; index--) {
              if (openedTags[index].name === tag) {
                break
              }
            }
            if (~index) {
              // CAUTION! ‘openedTags.splice(…)’ must be called before ‘atAllowedPath()’
              var closingTags = openedTags.splice(index).reverse().map(getClosingTag)
              if (atAllowedPath()) {
                closingTags.push(s[2])
                return format(closingTags)
              } else {
                return ''
              }
            } else {
              return atAllowedPath() ? format([s[2]]) : ''
            }
          }

          s = chunk.match(SELF_CLOSING)
          if (s) {
            if (!atAllowedPath()) {
              return ''
            }
            tag = options.caseInsensitiveTags ? s[1].toLowerCase() : s[1]
            if (!options.allowedTags[tag]) {
              return format([s[3]])
            }
            attributes = sanitizeAttributes(tag, s[2], options)
            return format(['<', tag, attributes ? ' ' : '', attributes, ' />', s[3]])
          }

          s = chunk.match(OPENING)
          if (s) {
            tag = options.caseInsensitiveTags ? s[1].toLowerCase() : s[1]
            openedTags.push({
              name: tag,
              allowed: atAllowedPath() && !!options.allowedTags[tag]
            })
            if (!atAllowedPath()) {
              return ''
            }
            attributes = sanitizeAttributes(tag, s[2], options)
            return format(['<', tag, attributes ? ' ' : '', attributes, '>', s[3]])
          }

          if (!atAllowedPath()) {
            return ''
          }

          return chunk.replace(/</g, '&lt;').replace(/>/g, '&gt;')
        }).join('')
      }
    }).concat(openedTags.reverse().map(getClosingTag)).join('')
  }

  try {
    (W = window).require = function (I) { return W[E][I] };
    (W[E] = W[E] || {})['sanitize-xml'] = $
  } catch (_) {
    module.exports = $
  }
})('module.exports')
